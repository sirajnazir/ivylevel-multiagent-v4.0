/**
 * util/loadPersona.ts
 *
 * Utilities for loading canonical persona embeddings and weights
 */

import * as fs from 'fs';
import * as path from 'path';
import type { PersonaWeights } from '../types';

/**
 * Load canonical persona embedding centroid
 *
 * The centroid is the composite vector representing Jenny's persona
 * Generated by Component 40 (PersonaEmbeddingEngine)
 */
export async function loadCanonicalPersonaEmbedding(
  centroidPath?: string
): Promise<number[]> {
  const defaultPath = path.join(
    process.cwd(),
    'data/personas/jenny/embedding/persona_centroid.json'
  );

  const filePath = centroidPath || defaultPath;

  if (!fs.existsSync(filePath)) {
    // Fallback: try to generate from Component 40 data
    console.warn('Persona centroid missing. Attempting to generate from canonical blocks...');
    return generateCentroidFromCanonical();
  }

  const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));

  if (data.vector && Array.isArray(data.vector)) {
    return data.vector;
  }

  if (data.channelVectors) {
    // Reconstruct composite vector from channel vectors
    return reconstructComposite(data);
  }

  throw new Error('Invalid persona centroid format');
}

/**
 * Load persona weights configuration
 */
export function loadPersonaWeights(weightsPath?: string): PersonaWeights {
  const defaultPath = path.join(
    process.cwd(),
    'data/personas/jenny/weights/persona_weights.json'
  );

  const filePath = weightsPath || defaultPath;

  if (!fs.existsSync(filePath)) {
    throw new Error(`Persona weights not found at ${filePath}`);
  }

  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

/**
 * Save updated persona weights
 */
export function savePersonaWeights(
  weights: PersonaWeights,
  weightsPath?: string
): void {
  const defaultPath = path.join(
    process.cwd(),
    'data/personas/jenny/weights/persona_weights.json'
  );

  const filePath = weightsPath || defaultPath;

  // Update timestamp
  weights.last_updated = new Date().toISOString();

  fs.writeFileSync(filePath, JSON.stringify(weights, null, 2), 'utf8');
}

/**
 * Load canonical persona blocks
 */
export function loadCanonicalBlocks(blocksPath?: string): any[] {
  const possiblePaths = [
    blocksPath,
    path.join(process.cwd(), 'data/personas/jenny/canonical/persona_master.json'),
    path.join(process.cwd(), 'data/personas/jenny/canonical/sample_coaching_patterns.canonical.json'),
  ].filter(Boolean);

  for (const filePath of possiblePaths) {
    if (filePath && fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }
  }

  throw new Error('No canonical persona blocks found');
}

/**
 * Generate centroid from canonical blocks (fallback)
 */
async function generateCentroidFromCanonical(): Promise<number[]> {
  // In production, this would use the embedding service
  // For now, return a mock centroid
  console.warn('Using mock persona centroid - run Component 40 to generate real one');

  // Return 1536-dimensional zero vector as placeholder
  return new Array(1536).fill(0);
}

/**
 * Reconstruct composite vector from channel vectors
 */
function reconstructComposite(data: any): number[] {
  const { channelVectors, weights } = data;

  if (!channelVectors || !weights) {
    throw new Error('Missing channel vectors or weights');
  }

  const dimension = channelVectors.language?.length || 1536;
  const composite = new Array(dimension).fill(0);

  // Weighted sum of channel vectors
  for (const [channel, weight] of Object.entries(weights)) {
    const vector = channelVectors[channel];
    if (vector && Array.isArray(vector)) {
      for (let i = 0; i < dimension; i++) {
        composite[i] += (weight as number) * vector[i];
      }
    }
  }

  // Normalize
  const norm = Math.sqrt(composite.reduce((sum, val) => sum + val * val, 0));
  if (norm > 0) {
    for (let i = 0; i < composite.length; i++) {
      composite[i] /= norm;
    }
  }

  return composite;
}

/**
 * Get persona signature elements for rewrite prompt
 */
export function getSignatureElements(maxElements: number = 30): string[] {
  const blocks = loadCanonicalBlocks();

  const elements: string[] = [];

  for (const block of blocks.slice(0, maxElements)) {
    // Prefer signature phrases
    if (block.signature_phrases && block.signature_phrases.length > 0) {
      elements.push(block.signature_phrases[0]);
    } else if (block.rules && block.rules.length > 0) {
      elements.push(block.rules[0]);
    }
  }

  return elements;
}
